  Для компіляції es6 -> es5 використовуємо Babel
npm init -y
  інсталюємо babel
npm install babel-cli babel-core babel-preset-es2015 --save-dev

  І в package.json вказуємо:
"scripts": {
  "build": "babel src -d dist --presets es2015"
  "watch": "babel src -d dist --presets es2015 -w"
}
"build" - назва скрипту який запуститься в консолі
babel - команда
src - папка де знаходяться файли для компіляції
-d dist - куда буде компілюватися
--presets es2015 - версія js -> es6
"watch" - слідкує за змінами

  Запуск
npm run build
або
npm run watch

-------------------------------------------------------
let
1) let - видно тільки в блоці
2) let - не піднімається, тобто видно тільки після об'яви
  тобто в var би було undefined в let буде error
      | console.log(a);
      | let a = 123;

-------------------------------------------------------
const
1) const Pi = 3.14159; - пишеться з великої букви
2) const - може бути обявлена лише раз і не має мінтися!
  бо буде помилка, але якщо це обєкт то можна міняти його властивості
3) const - не піднімається.
-------------------------------------------------------
spread operator - ...
1) spread operator - оператор який розгортає масив і витягує його елементи
 для вставки в інший масив, або як аргументи в функцію.
2) вставка:
      | let arr = [1, 2, 3];
      | let arr2 = [...arr, 4, 5];
      | // arr2 === [1, 2, 3, 4, 5];

3) в масив вставляється за допомогою методу concat
    а в функцію за допомогою apply

-------------------------------------------------------
template string - шаблонні строки
1) let name = "Nazar"
'Hi ' + name === `Hi ${name}`
2) template string мають тип string
3) console.log(`${x} + ${y} = ${x + y}`); // 2 + 8 = 10
  тому що перший плюс є частиною строки а другий виразу
4) додавання тегів:
      | let name = 'Bill';
      | console.log(upperName`Hello ${name}`);
      |
      | function upperName(literals, ...values) {
      |   return literals[0] + value.toUpperCase();
      | }
тут в 2-ій стрічці upperName - виступає в ролі тега який запускає функцію
де literals є масив ['Hello', ''], а ...values - name, або декілька аргументів
-------------------------------------------------------
functions parameters - параметри функції
1) default parameters - по замовчуванню:
  function add(x = 2, y = 3){return x + y}
2) rest parameters - робить з аргументів функції масив:
  function sum2(...values){...} => тому можна задавати будь-яку кількість аргументів

  ! див в parameters.js
-------------------------------------------------------
for...of
for...of - цикл який перебирає значення масиву
      |let browsers = ['Chrome', 'Firefox', 'Edge', 'Safari', 'Opera'];
      |
      |for(let browser of browsers) {
      |  console.log(browser);
      |}
-------------------------------------------------------
objects
1) Якщо вставляти в обєкт значення властивостей з змінних, то якщо імя проперті
співпадає з ім'ям змінної, то можна писати тільки ім'я проперті:
      | let firstName = 'Bill',
      |     lastName = 'Gates',
      |     email = 'billgates@microsoft.com';
      |
      | let person = {
      |   firstName,
      |   lastName,
      |   email,
      |   sayHello(){
      |     console.log(`Hi my name is ${firstName} ${lastName}`);
      |   }
      | };
2) метод можна обявляти без назви функції
3) можна динамічно вказувати проперті обєкту, що запишемо в змінну до обяви обєкту:

      let property = 'age';

      person = {
        [property]: '33'
      }
4) get i set властивості обєкту які в середині обєкту виглядають як метод, а
з зовні як властивість (викликатися без дужок) див objects.js
------------------------------------------------
classes
1) classes - це функції які створюють обєкти
2) constructor - це особливий метод, який визивається в момент створення обєкту.
  Він створює властивості обєкту і ініціалізує їх.
3) Властивості - це характеристики обєкту, які описують його, або що він має.
  Вони описуються в конструкторі і їх має кожен представник класу.
4) Методи класу пишуться після конструктора
5) Статичні властивості - це властивості, які належать самому класу, а не обєкту
  який створюється на його основі.
6) Статичні методи - це методи, які належать самому класу, а не обєкту
  який створюється на його основі. Використовують для створення допоміжних ункцій.
----------------------------------------------------
inheritance - наслідування
1) можна наслідувати клас, вказавши при обявленні класу інший клас який ми розширяємо:
class SubTask extends Task --- тут SubTask наслідує клас Task
2) Якщо в підкласу нема конструктора то він буде використовувати батьківський.
3) Якщо створити конструкор в підкласі, то потрібно підтягнути батьківський конструктор
  за допомогою super() - в яку можна передавати аргументи.
  Тоді виконається конструктор батьківський а потім власний.
4) Підклас наслідує всі методи і властивості, сетери гетери і все решта від
  батьківського класу. Але можна їх змінити.
----------------------------------------------------
arrow functions
1) let add = (x, y) => x + y;
  add(5, 7); // 12
2) let square = x => x * x; один аргумент
3) let getNumber = () => 42; взагалі без параметрів
4) let log = () => console.log('Login')
5) Якщо більше однієї строки, то має бути в дужках і return
let multiply = (x, y) => {
  let result = x * y;
  return result;
}
6) let getPerson = () => ({name: 'John'}); // якщо функція вертає літерал
обєктів, то її треба огорнути в круглі дужки.
7) Immediately invoked function expression
  (() => console.log('IIFE'))();
8) arr.forEach( num => sum += num ); // з forEach
9) let square = arr.map(num => num * 2);
10) Якщо використовувати стрілочну функцію в обекті як метод
  то this буде посилатися на window
11) Зато в setTimeout this збережеться і не треба зберігати this в змінну.
12) Не можна використовувати стрілочні функції з
  - конструкторами
  - bind()
  - apply()
  - call()
------------------------------------------------------------
Деструктивне присвоювання масивів
1) Приклад присвоювання змінним значення елементів масиву
let [js, php, rb] = ['JavaScript', 'PHP', 'Ruby'];
2) let scores = [3, 4, [9, 8]];
   let [low, mid, [high, higher]] = scores;
3) let num = [1, 2, 3, 4, 5];
   let [one, two, ...rest] = num;
   one === 1
   two === 2
   rest === [3, 4, 5]
4) function showNumber([low, high]){console.log(low, high)}
    showNumber([5, 9])
------------------------------------------------------------
Деструктивне присвоєння обєктів
1) Тут присвоюється змінним значення з обєктів
  (! імена змінних і властивостей мають співпадати)
let person = {
  firstName: 'Jonh',
  lastName: 'Doe'
};
let {firstName, lastName} = person;
2) А тут імена можуть бути іншими (тут first і last)
  let {firstName: first, lastName: last} = {firstName: 'Jonh', lastName: 'Doe'};
3) Можна вказувати значеня по замовчуванню як в аргументах функції
4) Вложені властивості:
  let user = {
    firstName: 'Jonh',
    lastName: 'Doe',
    social: {
      facebook: 'johndoe'
    }
  }
  let {firstName: first, lastName: last, social: {facebook}, age =25} = user;
--------------------------------------------------------------
promise
1) Приклад з  promise()
   let promise = applyForVisa(); // це функція для отримання візи :)
   // це асинхронна функція, тому поки вона виконується повертає назад обіцянку
   // в обіцянки є метод далі (then), який отримує два аргументи-функції resolve і reject
   // resolve - викрнується коли обіцянка виконується, а reject - коли ні
   // при цьому reject виконується на любому етапі відмови
   // promise.then(resolve, reject);
   // коли є більш ніж одна функція то для reject використовується метод catch
   promise.then(bookHotel);
   promise.then(buyTickets);
   promise.catch(cancelVacation);
